# GO-разработчик
[Установка и запуск проекта.](#установка-и-запуск)
## Вопросы

1. [Каким образом вы бы организовали информацию в Notion для повышения производительности и эффективности работы и какие самые популярные расширения в Notion?](#каким-образом-вы-бы-организовали-информацию-в-notion-для-повышения-производительности-и-эффективности-работы-и-какие-самые-популярные-расширения-в-notion)
2. [Чем git fetch отличается от git pull?](#чем-git-fetch-отличается-от-git-pull)
3. [В каких случаях GitHub Actions не нужен в проекте?](#в-каких-случаях-github-actions-не-нужен-в-проекте)
4. [Что такое Agile и лучше ли он водопада?](#что-такое-agile-и-лучше-ли-он-водопада)
5. [Зачем нужна Kanban-доска и из чего она состоит?](#зачем-нужна-kanban-доска-и-из-чего-она-состоит)
6. [Чем в SOLID отличаются друг от друга L и D? В чем их схожесть?](#чем-в-solid-отличаются-друг-от-друга-l-и-d-в-чем-их-схожесть)
7. [Приведи пример DRY И KISS(1 пример с соблюдением принципа, один с нарушением).](#приведи-пример-dry-и-kiss1-пример-с-соблюдением-принципа-один-с-нарушением)
8. [Какие в Go есть примитивы синхронизации?](#какие-в-go-есть-примитивы-синхронизации)
9. [Как реализовано наследование в Go? Чем отличается от классического понятия наследования в ООП?](#как-реализовано-наследование-в-go-чем-отличается-от-классического-понятия-наследования-в-ооп)
10. [Почему на Go практически не пишут расширения, библиотеки для других языков?](#почему-на-go-практически-не-пишут-расширения-библиотеки-для-других-языков)

### Каким образом вы бы организовали информацию в Notion для повышения производительности и эффективности работы и какие самые популярные расширения в Notion?

1. Я Notion не пользовался, но после обзора составил свое мнение относительно функционала этого сервиса (На своей прошлой работе я внедрил сервис Yougile и основываю свои рассуждения на опыте работы с ним). 

Сервис обладает очень широким спектром инструментов для организации работы как команд, так и для индивидуального использования. Я бы создал три основных раздела: 
* Основной - для вывода текущей и актуальной информации (текущие задачи, подгорающие задачи, напоминания и т.п.)
* Задачи - место, где будут все задачи по проекту. (в виде канбан доски, диаграммы Ганта или иного представления)
* Календарь - инструмент для организации встреч, совещаний, праздников и других мероприятий.

Популярные расширения (по данным Google):

* Google calendar - синхронизация событий и задач
* Zapier - автоматизация задач
* Notion enhancer - расширения
* Indify - виджеты

[⬆️ Вернуться к оглавлению](#вопросы)

### Чем git fetch отличается от git pull?

2. git fetch только загружает изменения. Это позволяет посмотреть вносимые изменения перед слиянием со своим кодом. git pull - это команда совмещающая git fetch + git merge. Т.е. ей надо пользоваться только если уверен, что загружаемый код не имеет конфликтов со своим кодом.

[⬆️ Вернуться к оглавлению](#вопросы)

### В каких случаях GitHub Actions не нужен в проекте?

3. GitHub Actions может не понадобиться в проекте, если в проекте уже присутствует сторонний CI/CD сервис. Так же в нем нет нужды для очень небольших проектов.

[⬆️ Вернуться к оглавлению](#вопросы)

### Что такое Agile и лучше ли он водопада?

4. Agile - это методология разработки представляющая итеративный подход для достижения цели проекта. Цель проекта, при этом, может корректироваться с каждой итерацией. В отличии от метода водопада, где заказчику  предоставляется конечный результат, согласованный с ним при составлении заказа, который, в процессе разработки, он изменить не может.

[⬆️ Вернуться к оглавлению](#вопросы)

### Зачем нужна Kanban-доска и из чего она состоит?

5. Kanban доска представляет собой колонки со стикерами задач. Колонки отражают статус задачи. Доска визуализирует степень выполнения задач. Так же, при определенных условиях, доска может показать загруженность/недогруженность команд и/или сотрудников.

[⬆️ Вернуться к оглавлению](#вопросы)

### Чем в SOLID отличаются друг от друга L и D? В чем их схожесть?

6. В вопросе спрашивается про "Принцип подстановки Лисков" - LSP и "Принцип инверсии зависимостей" DIP.

* Классическое объяснение LSP - очень замудрёное. Тем более, что в Го нет понятия "КЛАСС". Касательно Го - я бы объяснил этот принцип так: Если у нас объявлен интерфейс с методом, например,  Read, то любая имплементация обязана реализовать только чтение. И не важно что читать и откуда. Т.е. реализация метода Read не должна писать данные, слать их по сети, заниматься математикой и т.п.
* Принцип инверсии зависимостей, на мой взгляд, лучше всего объяснен в книге Роберта Мартина - Чистая архитектура. Этот принцип требует, что бы все зависимости были направлены в одну сторону - в сторону более высокоуровневых абстракций. Если это невозможно сделать, то надо применить интерфейс на стороне более высокого слоя, и на стороне более низкого слоя создать зависимость с помощью передачи в интерфейс структуры, метод(ы) которой реализуют этот интерфейс.
* Схожесть этих принципов в их целях и инструментах: Уменьшить связность кода, улучшить его читаемость, упростить его поддержку и модификацию. Для этого широко используются интерфейсы.

[⬆️ Вернуться к оглавлению](#вопросы)

### Приведи пример DRY И KISS(1 пример с соблюдением принципа, один с нарушением).

7. DRY с нарушением:
```
package main

import "fmt"

func main(){
    a,b,c:=3,4,5
    fmt.Printf("Result = %d\n",a*a+b*b*b-c)
    a,b,c=6,7,8
    fmt.Printf("Result = %d\n",a*a+b*b*b-c)
    a,b,c=7,8,9
    fmt.Printf("Result = %d\n",a*a+b*b*b-c)
}
```
DRY без нарушений:
```
package main

import "fmt"

func calc(a,b,c int)int{
return a*a+b*b*b-c
}

func main(){
    a,b,c:=3,4,5
    fmt.Printf("Result = %d\n",calc(a,b,c))
    a,b,c=6,7,8
    fmt.Printf("Result = %d\n",calc(a,b,c))
    a,b,c=7,8,9
    fmt.Printf("Result = %d\n",calc(a,b,c))
}
```
KISS с нарушением:
```
package main

import (
"fmt"
"math"
)

func calc(a,b,c int)int{
    if a<=int(math.MaxInt64) and a>=int(math.MinInt64){
        if b<=int(math.MaxInt64) and b>=int(math.MinInt64){
            if c<=int(math.MaxInt64) and c>=int(math.MinInt64){
        return a*a+b*b*b-c
            }
        }
    }
return a*a+b*b*b-c
}

func main(){
    a,b,c:=3,4,5
    fmt.Printf("Result = %d\n",calc(a,b,c))
    a,b,c=6,7,8
    fmt.Printf("Result = %d\n",calc(a,b,c))
    a,b,c=7,8,9
    fmt.Printf("Result = %d\n",calc(a,b,c))
}
```


KISS без нарушений:
```
package main

import "fmt"

func calc(a,b,c int)int{
return a*a+b*b*b-c
}

func main(){
    a,b,c:=3,4,5
    fmt.Printf("Result = %d\n",calc(a,b,c))
}
```

[⬆️ Вернуться к оглавлению](#вопросы)

### Какие в Go есть примитивы синхронизации?

8. Примитивы синхронизации:
* WaitGroup
* Mutex
* RWMutex
* Atomic
* Once

[⬆️ Вернуться к оглавлению](#вопросы)

### Как реализовано наследование в Go? Чем отличается от классического понятия наследования в ООП?

9. Наследование в Go реализовано через композицию. При композиции методы и поля встроеной структуры доступны непосредственно. Если сигнатура метода родительской структуры совпадет с сигнатурой метода встроенной структуры, то последний будет пререопределн.

В Go нет классического ООП. Похожие принципы реализованы другими методами:
* Наследование - реализовано композицией
* Полиморфизм - реализован интерфейсами
* Инкапсуляция - реализована неймингом

[⬆️ Вернуться к оглавлению](#вопросы)

### Почему на Go практически не пишут расширения, библиотеки для других языков?

10. На Go не пишут библиотек для работы с другими языками программирования, потому что Go - это прежде всего язык для разработки серверных приложений. Он используется для разработки инфраструктурных проектов. Для связи с другими объектами, приложения написанные на Go, обычно используют REST api интерфейс. Он достаточно надежен, быстр, прост и универсален. Так же приложения на Go тащат с собой весь свой runtime, поэтому для библиотек они великоваты.

[⬆️ Вернуться к оглавлению](#вопросы)

# Установка и запуск
1. установить утилиты: линтер и goose для миграций:
```
make install-golangci-lint
make install-goose
```
2. В папку `bin` сгенерировать и положить файлы сертификата и ключа для протокола  https:
```
openssl req -x509 -newkey rsa:4096 -keyout key.pem -out cert.pem -days 365 -nodes
```
3. Добавить переменные окружения - ключ шифрования для токена и пути нахождения файлов для http:
```
export TLS_CERT="/home/user/go/src/test-task/tasks/backend/GO/gremiha3/cert.pem"
export TLS_KEY="/home/user/go/src/test-task/tasks/backend/GO/gremiha3/key.pem"
export JWT_KEY="-my-256-bit-secret-"
```
4. собрать docker контейнеры:
    * postgres master
    * postgres replica
    * приложение
```
docker-compose up -d
```
после завершения команды контейнер с репликой упадет, т.к. после его конфигурирования требуется перезапуск. Просто еще раз пишем:
```
docker-compose stop
docker-compose start
```
5. Дальше заливаем миграции:
```
make local-migration-up
```
6. Открываем браузер:
```
https://localhost:8443/docs/index.html#/
```


## Примеры запросов:
### Регистрация:
```
http --verify=no POST https://localhost:8443/user/register login=qwerty@ya.com password=123456 username=Nikola role=super
```
### Авторизация:
```
http --verify=no POST https://localhost:8443/user/login login=qwerty@ya.com password=123456
```
### Вывести список всех пользователей:
```
http --verify=no GET https://localhost:8443/users Authorization:"Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE3MjQwNDc2NTcsImxvZ2luIjoicXdlcnR5QHlhLmNvbSIsInJvbGUiOiJzdXBlciJ9.gLvjroKKz2FQrdDAt-SzaXMLTICl0s90VuRHC4wu6zo"
```
### Из браузера:
```
fetch(
  'https://localhost:8443/users',
  {
    method: 'GET',
    headers: { 'Content-Type': 'application/json','Authorization': 'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE3MjQwNDY4NTYsImxvZ2luIjoiY21kQGNtZC5ydSIsInJvbGUiOiJzdXBlciJ9.Lz1tIHXDiSJQy6JspvFRSCCsGoNSFOg2S0SIzhTg_yk' }
  }
).then(resp => resp.text()).then(console.log)
```
[⬆️ Вернуться к оглавлению](#вопросы)